function [ rmse ] = calc_rmseCorr( camera, sourcex, sourcey, N,...
    seed, pixel_pitch, numAngSensors, f_lenslets, n)
%[ rmse ] = calc_rmseCorr( camera, sourcex, sourcey, N,...
%    seed, pixel_pitch, numAngSensors, f_lenslets, n)
%
%   N - number of rays to send for original spot
%   n - number of monte carlo iterations for correction (per pixel)

addpath('monte_carlo_corr');

if isempty(seed)
    rng('shuffle')
else
    rng(seed)
end

%%%%%%%%%%
tic
%%%%%%%%%%

sd = camera(end).sd; % semidiamter
si = camera(end).d;  % distance from lens to image plane
[pupil_radius, dist_to_pupil] = calc_entrpupil(camera);

% Generate random uniform array of points covering entrance pupil
Ns = round(1.28*N + 2.5*sqrt(N) + 100);
Xrand = (rand(Ns,1)*2-1)*pupil_radius;
Yrand = (rand(Ns,1)*2-1)*pupil_radius;
I = find(sqrt(Xrand.^2+Yrand.^2)<=pupil_radius);
Xrand = Xrand(I(1:N));
Yrand = Yrand(I(1:N));

x0 = sourcex*ones(N,1); 
y0 = sourcey*ones(N,1);

xt = atan((Xrand-x0)/(dist_to_pupil));
yt = atan((Yrand-y0)/(dist_to_pupil));



xout = zeros(N,1); yout = zeros(N,1);
xtout = zeros(N,1); ytout = zeros(N,1);
for i = 1:N
    [ xout(i), xtout(i), yout(i), ytout(i) ] = ...
        traceRayForward_withLenslets( x0(i), y0(i), xt(i), yt(i), camera,...
        f_lenslets, pixel_pitch );
end

%%%%%%%%%%
disp('Trace
toc
%%%%%%%%%%

xmax = (floor(max(xout)/pixel_pitch)+1)*pixel_pitch;
xmin = (floor(min(xout)/pixel_pitch))*pixel_pitch;
ymax = (floor(max(yout)/pixel_pitch)+1)*pixel_pitch;
ymin = (floor(min(yout)/pixel_pitch))*pixel_pitch;
xrange = [xmin xmax]; yrange = [ymin ymax];

ImgSize(1) = (xrange(2) - xrange(1)) / (pixel_pitch/numAngSensors);
ImgSize(2) = (yrange(2) - yrange(1)) / (pixel_pitch/numAngSensors);
rawimg = zeros(round(ImgSize));

numPixX = floor((xrange(2)-xrange(1))/pixel_pitch);
numPixY = floor((yrange(2)-yrange(1))/pixel_pitch);

if (numPixX > 8000 || numPixY > 8000)
    warning('point discarded');
    rmse = nan;
    return
end

xout_real = xout(~isnan(xout) & ~isnan(yout));
yout_real = yout(~isnan(xout) & ~isnan(yout));
xtout_real = xtout(~isnan(xout) & ~isnan(yout));
ytout_real = ytout(~isnan(xout) & ~isnan(yout));

I = 1;
for i = 1:numel(xout_real)
    if ~(xout_real(i) > xrange(2) || xout_real(i) <= xrange(1) || ...
            yout_real(i) > yrange(2) || yout_real(i) <= yrange(1))
        % Determine pixel location
        pixX = floor((xout_real(i)-xrange(1))/(pixel_pitch/numAngSensors))+1;
        pixY = floor((yout_real(i)-yrange(1))/(pixel_pitch/numAngSensors))+1;
        % Increment that bin
        rawimg(pixX, pixY) = rawimg(pixX, pixY) + I;
    end
            
end

ABCD_parax = calc_abcd(camera);
ABCD_parax(1,2) = 0; % enforce imaging condition


%image = cellfun(@sum,cellfun(@sum, binned_data, 'UniformOutput', 0));
%figure; plot(xout, yout, 'o'); colorbar;

[ correctedRawImg, xout, yout, weights ] = monteCarloCorrection_bruteForce( rawimg, camera, ...
    xrange, yrange, pixel_pitch,...
    numAngSensors, f_lenslets, ABCD_parax, n);
%figure; plot(xout, yout, 'o'); colorbar;
rmse = calc_rmse(xout, yout, [], [], weights);


end

